1) Ranking Functions (ROW_NUMBER, RANK, DENSE_RANK, PERCENT_RANK)
WITH product_region_revenue AS (
  SELECT
    c.region_id,
    r.region_name,
    p.product_id,
    p.product_name,
    SUM(oi.quantity * oi.unit_price) AS revenue
  FROM orders o
  JOIN customers c    ON c.customer_id = o.customer_id
  JOIN regions r      ON r.region_id = c.region_id
  JOIN order_items oi ON oi.order_id = o.order_id
  JOIN products p     ON p.product_id = oi.product_id
  GROUP BY c.region_id, r.region_name, p.product_id, p.product_name
)
SELECT
  region_name,
  product_name,
  revenue,
  ROW_NUMBER()  OVER (PARTITION BY region_name ORDER BY revenue DESC) AS rn,
  RANK()        OVER (PARTITION BY region_name ORDER BY revenue DESC) AS rnk,
  DENSE_RANK()  OVER (PARTITION BY region_name ORDER BY revenue DESC) AS dense_rnk,
  PERCENT_RANK()OVER (PARTITION BY region_name ORDER BY revenue DESC) AS pct_rnk
FROM product_region_revenue
ORDER BY region_name, rnk;

Shows the top products/customers per region by revenue. Helps quickly spot the best performers (and handles ties).
----------------------------------------------------------------------------------------

2) Aggregate Window (SUM OVER, AVG OVER) + Frames (ROWS / RANGE)
WITH monthly_sales AS (
  SELECT
    c.region_id,
    r.region_name,
    TRUNC(o.order_date, 'MM') AS month_start,
    SUM(oi.quantity * oi.unit_price) AS revenue
  FROM orders o
  JOIN customers c    ON c.customer_id = o.customer_id
  JOIN regions r      ON r.region_id = c.region_id
  JOIN order_items oi ON oi.order_id = o.order_id
  GROUP BY c.region_id, r.region_name, TRUNC(o.order_date, 'MM')
)
SELECT
  region_name,
  month_start,
  revenue,
  SUM(revenue) OVER (
    PARTITION BY region_name
    ORDER BY month_start
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS running_total_rows,
  AVG(revenue) OVER (
    PARTITION BY region_name
    ORDER BY month_start
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) AS moving_avg_3m_rows
FROM monthly_sales
ORDER BY region_name, month_start;

-- RANGE frame example (Oracle supports INTERVAL with RANGE)
SELECT
  c.customer_id,
  c.full_name,
  o.order_date,
  SUM(oi.quantity * oi.unit_price) AS order_value,
  SUM(SUM(oi.quantity * oi.unit_price)) OVER (
    PARTITION BY c.customer_id
    ORDER BY o.order_date
    RANGE BETWEEN INTERVAL '90' DAY PRECEDING AND CURRENT ROW
  ) AS rolling_90d_spend_range
FROM orders o
JOIN customers c    ON c.customer_id = o.customer_id
JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY c.customer_id, c.full_name, o.order_date
ORDER BY c.customer_id, o.order_date;

Shows how sales add up over time and the 3-month average trend. Helps see if revenue is growing steadily or not.

--------------------------------------------------------------------------------------

3) Navigation Functions (LAG / LEAD)
WITH monthly_sales AS (
  SELECT
    r.region_name,
    TRUNC(o.order_date, 'MM') AS month_start,
    SUM(oi.quantity * oi.unit_price) AS revenue
  FROM orders o
  JOIN customers c    ON c.customer_id = o.customer_id
  JOIN regions r      ON r.region_id = c.region_id
  JOIN order_items oi ON oi.order_id = o.order_id
  GROUP BY r.region_name, TRUNC(o.order_date, 'MM')
)
SELECT
  region_name,
  month_start,
  revenue,
  LAG(revenue)  OVER (PARTITION BY region_name ORDER BY month_start) AS prev_month_revenue,
  LEAD(revenue) OVER (PARTITION BY region_name ORDER BY month_start) AS next_month_revenue,
  CASE
    WHEN LAG(revenue) OVER (PARTITION BY region_name ORDER BY month_start) IS NULL THEN NULL
    WHEN LAG(revenue) OVER (PARTITION BY region_name ORDER BY month_start) = 0 THEN NULL
    ELSE ROUND(
      (revenue - LAG(revenue) OVER (PARTITION BY region_name ORDER BY month_start))
      / LAG(revenue) OVER (PARTITION BY region_name ORDER BY month_start) * 100, 2
    )
  END AS mom_growth_pct
FROM monthly_sales
ORDER BY region_name, month_start;

Compares this monthâ€™s sales to the previous/next month. Helps detect increase or decrease in sales.
--------------------------------------------------------------------------------------
4) Distribution Functions (NTILE(4), CUME_DIST)
WITH customer_spend AS (
  SELECT
    c.customer_id,
    c.full_name,
    r.region_name,
    SUM(oi.quantity * oi.unit_price) AS total_spend
  FROM customers c
  JOIN regions r      ON r.region_id = c.region_id
  LEFT JOIN orders o  ON o.customer_id = c.customer_id
  LEFT JOIN order_items oi ON oi.order_id = o.order_id
  GROUP BY c.customer_id, c.full_name, r.region_name
)
SELECT
  customer_id,
  full_name,
  region_name,
  total_spend,
  NTILE(4)    OVER (ORDER BY total_spend DESC NULLS LAST) AS spend_quartile,
  CUME_DIST() OVER (ORDER BY total_spend ASC  NULLS FIRST) AS spend_cume_dist
FROM customer_spend
ORDER BY total_spend DESC NULLS LAST;

Groups customers into 4 spend levels (high to low). Helps target VIP customers and re-engage low spenders.
